---
title: "Задание 1"
author: 
- "Гуреев Кирилл Аалександрович"
- "+7 (908) 27 35 636"
- "gureev.prof@gmail.com"
date: 'Assigned: October 7, 2019'
output: 
  html_document:
    css: style.css
    toc: true
    toc_depth: 3
    theme: paper
    highlight: tango
runtime: shiny
---

#####  
##### Некоторые пометки в части размера шрифтов:
 <font size="1"> This is my text number1</font>  
 <font size="2"> This is my text number 2</font>  
 <font size="3"> This is my text number 3</font>  
 <font size="4"> This is my text number 4</font>  
 <font size="5"> This is my text number 5</font>  
 <font size="6"> This is my text number 6</font> 
 
`Так можно разместить код в тексте: verbatim code`  

##### Для выполнения задания следуйте следующему:

`r getRversion()`
```{r echo=FALSE}
getRversion()
```

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

1. Замените "Введите имя" в поле `author:` на свое ФИО.
2. Выполняйте задание путем редактирования файла `homework1.Rmd`.
3. После выполнения работы, убедитесь, что ваш код выполняется как в консоле, так и путем запуска knit HTML, поменяйте название сохраненного файла на `homework1_Вашеимя.Rmd` (Вашеимя поменяйте на ФИО) и отправьте на почту "itetin.emms@yandex.ru"

##### Homework tips:
1. Вместо построчного запуска путем нажатия `<ctrl-enter>` можно запускать целые блоки кода. Посмотрите опции в меню <Chunks>
2. Проверяйте код в консоле, запускайте Knit HTML по мере выполнения для проверки на ошибки.


### Задание 1: Простые Булевы операции

> Tip:  Обратите внимание, что в каждом блоке кода стоит опция `eval = FALSE`. Это говорит R Markdown отображать код внутри блока, но не запускать его. Для проверки ответа, убедитесь, что код работает в консоли для различных значений переменной `x`

##### (a) Проверка равенства.

Дана переменная `x`, запишите Булево выражение, которое возвращает `TRUE` если переменная `x` равна `94842` (numeric).  
```{r, eval = FALSE}

# РЕШЕНИЕ:
# В коде Вам требуется ввести число
x<-as.numeric(readline(prompt="Введите интересующее Вас число: "))==94842
print (x)
```

##### (b) Проверка неравенства.

Дана переменная `x`, запишите Булево выражение, которое возвращает `TRUE` если переменная `x` *не* `NA` (т.е., не пропущена).

```{r, eval = FALSE}

# РЕШЕНИЕ:
# В коде Вам требуется ввести число
x<-is.na((readline(prompt="Введите интересующее Вас число: ")))==FALSE
print (x)
```

##### (c) Проверка, что число находится в заданном диапазоне. 

Пусть дано (можно отрицательное) число `x`, запишите Булево выражение, которое возвращает `TRUE` только в том случае, если `x` меньше `-12` или больше, чем `29`.  

```{r, eval=FALSE}

# РЕШЕНИЕ:
# В коде Вам требуется ввести число
x<-as.numeric(readline(prompt="Введите интересующее Вас число: "))
print ((-12>x) | (x>29))
```

##### (d) Более сложное задание.

Задано целове число `x`, запишите Булево выражение, которое возвращает `TRUE` только в том случае, если `x` является **нечетным** числом между -8 и 12 или 100 и 150.  

```{r, eval=FALSE}
# РЕШЕНИЕ:
# В коде Вам требуется ввести число
x<-as.numeric(readline(prompt="Введите интересующее Вас число: "))
if (((x>=-8 & x<=12)|(x>=100 & x<=150)) & ((x %% 2)!=0)) {
  cat(sprintf("число %s соответствует условиям \n", x))
} else {
  cat(sprintf("число %s НЕ соответствует условиям \n", x))
}
# Мне нравится! Шикарно получилось )
```

**Tip**: Остаток от деления: `%%`.  Для целых `x` и `y`, `x %% y` является остатком от `x` разделенного на `y`.  

### Задание 2: Векторные Булевы операции

##### (a) R имеет два типа Булевых операторов, одинарный (`&`, `|`) и двойной (`&&`, `||`).  

Один из этих операторов имеет свойство, называемое *lazy evaluation*, другой - не имеет.  Они ведут себя по-разному, когда применяются к *vectors*.  

Прочитайте (`help("||")`) и постройте несколько примеров, чтобы помочь разобраться, как эти операторы себя ведут

В качестве отправной точки, попробуйте следующие примеры в консоле:

```{r, eval = FALSE}
# Example:  Переменная y.prob2a не задана.  
# (Не задавайте ее!)
# Что произойдет при запуске кода?
x.prob2a <- 5
(x.prob2a < 10) | (y.prob2a > 2)
(x.prob2a < 10) || (y.prob2a > 2)
```

```{r, eval = FALSE}
# Задайте векторы
x.prob2a.vec <- c(TRUE, FALSE, FALSE)
y.prob2a.vec <- c(TRUE, TRUE, FALSE)

# Примените различные Булевы операции и посмотрите на результат
x.prob2a.vec & y.prob2a.vec
x.prob2a.vec && y.prob2a.vec
x.prob2a.vec | y.prob2a.vec
x.prob2a.vec || y.prob2a.vec
```

Вы можете объяснить, что происходит?  Ниже кратко поясните.

<font color="#336600">

**Как я понял... Длинные (двойные) - короткое сравнение. Т.е. сравниваются только первые символы. При этом короткие можно использовать только при полной уверенности, что ветора равны по размерности. Получается, что использовать второй лучше, но можно не всегда)**

</font>

##### (b) Применение `all()`
Опросили двух человек, которые выбирали из двух вариантов ответов: [Facebook, Twitter], [Firefox, Chrome], [Mac, PC], [Summer, Winter]. Результаты приведены ниже

```{r}
help(all)
alice.prefs <- c("Twitter", "Chrome", "Mac", "Summer")
bob.prefs <- c("Facebook", "Chrome", "PC", "Summer")
```

Примените функцию `all()` для определения, одинаковы ли предпочтения людей. (Ваш код должен выводить одиночную Булеву переменную `TRUE` или `FALSE`)

```{r}
# Функция проверяет попарное равенство и устанавливает TRUE, если все попарно равны
all(alice.prefs==bob.prefs)

```

##### (c) Применение `any()` 

Используйте функцию `any()` для определения, имеют ли два человека какие-либо общие предпочтения.
function to determine if the two people have any preferences in common.  (Ваш код должен выводить одиночную Булеву переменную `TRUE` или `FALSE`)
```{r}
# Согласно представленному результату у парняг есть что-то общее
any(alice.prefs==bob.prefs)
```


##### (d) Пропущенные значения.

Пусть `age` будет вектором. Он определен ниже

```{r}
age <- c(18, NA, 25, 71, NA, 45, NA, NA, 18)
```

Напишите Булево выражение, которое проверяет каждое значение на пропущенное (`NA`). Ваше выражение должно возвращать Булевый вектор, имеющий длину как у `age`.

```{r}
age <-is.na(age)
print(age)
```

### Задание 3: Обращение к элементам вектора

##### (a) Задание по `which()` 

Напишите код, который возвращает пропущенные индексы `age` 

```{r}
# Немного не понял задания, потому написал все варианты вывода
which(age[])
which(age[]==FALSE)
which(age[] | age[]==FALSE)
```

##### (b) Получение присутствующих значений

Напишите код, который использует негативные индексы и ваше решение из части (а), чтобы вернуть только те значения 
`age`, которые присутствуют (ваш код должен возвращать вектор с элементами: 18, 25, 71, 45, 18)

```{r}
# на всякий случай переприсвою
age <- c(18, NA, 25, 71, NA, 45, NA, NA, 18)
print(age)
# такая версия выводит индексы
print(which(as.logical(age)==TRUE))
print(which(is.na(age)!=TRUE))
# а иакая выводит сами значения
print(age[which(as.logical(age)==TRUE)])
print(age[which(is.na(age)!=TRUE)])
```

##### (c)  Более прямой путь получения присутствующих значений

Используя оператор `!` и функцию `is.na()` напишите выражение, которое возвращает присутсвующие значения переменной `age`

```{r}
print(which(is.na(age)!=TRUE))
print(age[which(is.na(age)!=TRUE)])
```

##### (d) Больше практики по `which()` 

Для следующей задачи вернемся к набору данных `cars`

```{r}
speed <- cars$speed
dist <- cars$dist
```

Напишите код, чтобы определить какие машины останавливаются за 15 футов или за большее расстояние.

```{r}
# Как я понял Cars -готовая база в R Studio
# Судя по всему размерность базы 50
# Видимл требуется вывести список машин, по какому-то параметру больше-равно 15
length(cars)
length(speed)
length(dist)

y<-dist #или написать y<-speed
print(which(y>=15))
x<-x[which(y>=15)]
print(length(x))
```

##### (e) Задание `which.min`, `which.max`

Используйте функцию `which.min()` для определения *кратчайшей* дистанции остановики. (Код должен возвращать индекс автомобиля)

```{r}
y<-dist #или написать y<-speed
dist
print(which.min(y))
print(y[which.min(y)])
print(which.max(y))
print(y[which.max(y)])
```

##### (f) Еще практика

Используйте функцию `which.max()`для определения *скорости* машины с *длиннейшей* дистанцией остановки. (Код должен возвращать скорость автомобиля)

```{r}
dist
y<-dist
x<-speed
print(x[which.max(y)])
```

### Задание 4: Основы работы с data.frame


##### (a) Импорт данных
Необходимо загрузить файл по ссылке https://cloud.mail.ru/public/4wCu/2s76mCEB7 В файле survey_data.csv содержатся данные опроса. Поместите файл в рабочий каталог, затем импортируйте данные функцией `read.csv()`в переменную `survey`

```{r}
survey <- read.csv("https://cloud.mail.ru/public/4wCu/2s76mCEB7", 
               header = TRUE, stringsAsFactors = TRUE)
setwd("d:/R/R Courses/Lessons")
survey <- read.csv("survey_data.csv")
```
**Tip**: Не используйте прямое скачивание файла из облака.

##### (b) `$` нотация

Воспользуйтесь оператором `$` для выбора колонки TVhours из `survey`

```{r}
# Делаем по аналогии
TVhours<-survey$TVhours
print(TVhours)
```

##### (c) [,] нотация

Повторите часть (b), используя `[,]` нотацию,  т.е., используйте `[,]` для выбора столбца TVhours из `survey` по имени (воспользуйтесь именем "TVhours" вместо указания на номер столбца)

```{r}
survey <- read.csv("survey_data.csv")
length(survey)
head(survey[c(1:6)]) # так проиходит импорт заголовка по номерам столбца
head(survey[c("Program","Editor")]) # так проиходит импорт заголовка по названия

# Вот такой окончательный вариант ответа
TVhours<-survey[c("TVhours")] 

```

##### (d) [[]] нотация

Повторите часть (c) с использованием [[]] нотации

```{r}
TVhours<-survey[["TVhours"]]
```

##### (e) [] нотация

Повторите часть (d) используя одиночные скобки (`[ ]`) 
(В этот раз возвращается *data frame*, а не вектор.) 

```{r}
survey <- read.csv("survey_data.csv")
TVhours<-survey["TVhours"]
TVhours
```

##### (f) `subset()` 

Используйте функцию `subset()` для выбора всех данных из `survey` о Program и OperatingSystem для респондентов, у которых Rexperience is "Never used" *или* кто смотрел TV 5 или более часов на прошлой неделе. 

```{r}
survey <- read.csv("survey_data.csv")
survey[((survey$Rexperience == "Never used") | (survey$TVhours>5)) ,]

```


### Задача 5: практика программирования

##### (a) Bar graph

Создайте столбчатую диаграмму ответов респондентов по Rexperience 

```{r, fig.align='center', fig.width=7, fig.height=4}
library(ggplot2)
qplot(survey[["Rexperience"]])
```

##### (b) Inline code 

Замените все знаки вопроса в следующем параграфе inline кодом, дополняющим подходящую информацию
Replace all occurrences of ???? in the paragraph below with an inline code chunk supplying the appropriate information.

survey <- read.csv("survey_data.csv")
nrow(survey) 
mism<-survey[survey$Program != "MISM",]
nrow(mism) 
ymism<-survey[survey$Program == "MISM",]
yrmism<-survey[(survey$Program == "MISM") & (survey$Rexperience == "Basic competence") ,]

macosx<-survey[survey$OperatingSystem == "Mac OS X",]
proc1<-nrow(mism) /nrow(survey) *100
proc2<-nrow(yrmism) /nrow(ymism) *100

> Из nrow(survey) респондентов опроса, nrow(mism)  НЕ были в программе MISM. Мы обнаружили, что proc1% от числа студентов в классе используют Mac OS X.  proc2% от MISM студентов имеют базовые компетенции в R.
