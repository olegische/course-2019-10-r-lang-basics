---
title: "Задание 1"
author: ""
date: 'Assigned: October 7, 2019'
output: 
  html_document:
    toc: true
    toc_depth: 3
    theme: paper
    highlight: tango
---
##### Для выполнения задания следуйте следующему:

1. Замените "Введите имя" в поле `author:` на свое ФИО.
2. Выполняйте задание путем редактирования файла `homework1.Rmd`.
3. После выполнения работы, убедитесь, что ваш код выполняется как в консоле, так и путем запуска knit HTML, поменяйте название сохраненного файла на `homework1_Вашеимя.Rmd` (Вашеимя поменяйте на ФИО) и отправьте на почту ""

##### Homework tips:
1. Вместо построчного запуска путем нажатия `<ctrl-enter>` можно запускать целые блоки кода. Посмотрите опции в меню <Chunks>
2. Проверяйте код в консоле, запускайте Knit HTML по мере выполнения для проверки на ошибки.


### Задание 1: Простые Булевы операции

> Tip:  Обратите внимание, что в каждом блоке кода стоит опция `eval = FALSE`. Это говорит R Markdown отображать код внутри блока, но не запускать его. Для проверки ответа, убедитесь, что код работает в консоли для различных значений переменной `x`

##### (a) Проверка равенства.

Дана переменная `x`, запишите Булево выражение, которое возвращает `TRUE` если переменная `x` равна `94842` (numeric).  
```{r, eval = FALSE}
x = 94842
x == 94842

#x <- c(94841,94842,94843); names(x)<- as.character(x)
#x <- (x == 94842)
#x
```

##### (b) Проверка неравенства.

Дана переменная `x`, запишите Булево выражение, которое возвращает `TRUE` если переменная `x` *не* `NA` (т.е., не пропущена).

```{r, eval = FALSE}
x = 5
x | NA
length(x) != 0
```

##### (c) Проверка, что число находится в заданном диапазоне. 

Пусть дано (можно отрицательное) число `x`, запишите Булево выражение, которое возвращает `TRUE` только в том случае, если `x` меньше `-12` или больше, чем `29`.  

```{r}
x = -13
x < -12 | x > 29

#x <- c(-13,0,30); names(x)<- as.character(x)
#x <- (x < -12 | x > 29)
#x
```

##### (d) Более сложное задание.

Задано целове число `x`, запишите Булево выражение, которое возвращает `TRUE` только в том случае, если `x` является **нечетным** числом между -8 и 12 или 100 и 150.  

```{r, eval=FALSE}
x = 1
((x > -8 & x < 12) | (x > 100 & x < 150 )) & ((x %% 2) != 0)

#x <- c(-10,-9,0,1,13,14,101,102,151,151); names(x)<- as.character(x)
#x <- (((x > -8 & x < 12) | (x > 100 & x < 150 )) & ((x %% 2) != 0))
#x
```

**Tip**: Остаток от деления: `%%`.  Для целых `x` и `y`, `x %% y` является остатком от `x` разделенного на `y`.  

### Задание 2: Векторные Булевы операции

##### (a) R имеет два типа Булевых операторов, одинарный (`&`, `|`) и двойной (`&&`, `||`).  

Один из этих операторов имеет свойство, называемое *lazy evaluation*, другой - не имеет.  Они ведут себя по-разному, когда применяются к *vectors*.  

Прочитайте (`help("||")`) и постройте несколько примеров, чтобы помочь разобраться, как эти операторы себя ведут

В качестве отправной точки, попробуйте следующие примеры в консоле:

```{r, eval = FALSE}
# Example:  Переменная y.prob2a не задана.  
# (Не задавайте ее!)
# Что произойдет при запуске кода?
x.prob2a <- 5
(x.prob2a < 10) | (y.prob2a > 2)
(x.prob2a < 10) || (y.prob2a > 2)

(x.prob2a < 10) & (y.prob2a > 2)
(x.prob2a < 10) && (y.prob2a > 2)

x.prob2a <- 11
(x.prob2a < 10) || (y.prob2a > 2)

```

```{r, eval = FALSE}
# Задайте векторы
# Пример 1
x.prob2a.vec <- c(TRUE, FALSE, FALSE)
y.prob2a.vec <- c(TRUE, TRUE, FALSE)

# Примените различные Булевы операции и посмотрите на результат
x.prob2a.vec & y.prob2a.vec
x.prob2a.vec && y.prob2a.vec
x.prob2a.vec | y.prob2a.vec
x.prob2a.vec || y.prob2a.vec

# Пример 2
x.prob2a.vec <- c(TRUE, TRUE, FALSE)
y.prob2a.vec <- c(FALSE, TRUE, FALSE)

x.prob2a.vec && y.prob2a.vec

# Пример 3
x.prob2a.vec <- c(FALSE, TRUE, FALSE)
y.prob2a.vec <- c(TRUE, TRUE, FALSE)

x.prob2a.vec || y.prob2a.vec
```

Вы можете объяснить, что происходит?  Ниже кратко поясните.

<font color="#336600">

Применительно к векторам, короткие формы AND и OR производят поэлементное сравнение векторов.
Длинные формы AND и OR производят сравнение только первых элементов веторов. Это показывает пример 2 (строка 122).
Причем сравнение выполняется до тех пор, пока результат не будет определен. Это поведение можно изучить на следующих примерах:
- строка 97 (при x.prob2a = 5) -- при получении значения операции x.prob2a < 10 (TRUE), операция сравнения y.prob2a > 2 не выполняется
- строка 103 (она идентична строке 97, но x.prob2a присвоено значение 11) -- при получении значения операции x.prob2a < 10 (FALSE), производится выполнение операции y.prob2a > 2, для вычисления второго значения операции сравнения, в результате чего, скрипт завершается с ошибкой
- пример 3 (строка 129).

</font>

##### (b) Применение `all()`
Опросили двух человек, которые выбирали из двух вариантов ответов: [Facebook, Twitter], [Firefox, Chrome], [Mac, PC], [Summer, Winter]. Результаты приведены ниже

```{r}
alice.prefs <- c("Twitter", "Chrome", "Mac", "Summer")
bob.prefs <- c("Facebook", "Chrome", "PC", "Summer")
```

Примените функцию `all()` для определения, одинаковы ли предпочтения людей. (Ваш код должен выводить одиночную Булеву переменную `TRUE` или `FALSE`)

```{r}
all(alice.prefs == bob.prefs)

#alice.prefs <- bob.prefs
#all(alice.prefs == bob.prefs)
```

##### (c) Применение `any()` 

Используйте функцию `any()` для определения, имеют ли два человека какие-либо общие предпочтения.
function to determine if the two people have any preferences in common.  (Ваш код должен выводить одиночную Булеву переменную `TRUE` или `FALSE`)
```{r}
any(alice.prefs == bob.prefs)
```


##### (d) Пропущенные значения.

Пусть `age` будет вектором. Он определен ниже

```{r}
age <- c(18, NA, 25, 71, NA, 45, NA, NA, 18)
```

Напишите Булево выражение, которое проверяет каждое значение на пропущенное (`NA`). Ваше выражение должно возвращать Булевый вектор, имеющий длину как у `age`.

```{r}
age | NA
length(age | NA) == length(age)
```

### Задание 3: Обращение к элементам вектора

##### (a) Задание по `which()` 

Напишите код, который возвращает пропущенные индексы `age` 

```{r}
which(age[!age] | NA)
which(age | NA)
# не могу выполнить задание без is.na. which пропускает логическую константу NA -- получаю вектор нулевой длины integer(0)
```

##### (b) Получение присутствующих значений

Напишите код, который использует негативные индексы и ваше решение из части (а), чтобы вернуть только те значения 
`age`, которые присутствуют (ваш код должен возвращать вектор с элементами: 18, 25, 71, 45, 18)

```{r}
age[which(age | NA)]
```

##### (c)  Более прямой путь получения присутствующих значений

Используя оператор `!` и функцию `is.na()` напишите выражение, которое возвращает присутсвующие значения переменной `age`

```{r}
age[which(!is.na(age))]
```

##### (d) Больше практики по `which()` 

Для следующей задачи вернемся к набору данных `cars`

```{r}
speed <- cars$speed
dist <- cars$dist
```

Напишите код, чтобы определить какие машины останавливаются за 15 футов или за большее расстояние.

```{r}
which(dist >= 15)
```

##### (e) Задание `which.min`, `which.max`

Используйте функцию `which.min()` для определения *кратчайшей* дистанции остановики. (Код должен возвращать индекс автомобиля)

```{r}
which.min(dist)
```

##### (f) Еще практика

Используйте функцию `which.max()`для определения *скорости* машины с *длиннейшей* дистанцией остановки. (Код должен возвращать скорость автомобиля)

```{r}
speed[which.max(dist)]
```

### Задание 4: Основы работы с data.frame


##### (a) Импорт данных
Необходимо загрузить файл по ссылке https://cloud.mail.ru/public/4wCu/2s76mCEB7 В файле survey_data.csv содержатся данные опроса. Поместите файл в рабочий каталог, затем импортируйте данные функцией `read.csv()`в переменную `survey`

```{r}
survey <- read.csv('survey_data.csv')

```
**Tip**: Не используйте прямое скачивание файла из облака.

##### (b) `$` нотация

Воспользуйтесь оператором `$` для выбора колонки TVhours из `survey`

```{r}
survey$TVhours
```

##### (c) [,] нотация

Повторите часть (b), используя `[,]` нотацию,  т.е., используйте `[,]` для выбора столбца TVhours из `survey` по имени (воспользуйтесь именем "TVhours" вместо указания на номер столбца)

```{r}
survey[,'TVhours']
```

##### (d) [[]] нотация

Повторите часть (c) с использованием [[]] нотации

```{r}
survey[["TVhours"]]
```

##### (e) [] нотация

Повторите часть (d) используя одиночные скобки (`[ ]`) 
(В этот раз возвращается *data frame*, а не вектор.) 

```{r}
survey["TVhours"]
```

##### (f) `subset()` 

Используйте функцию `subset()` для выбора всех данных из `survey` о Program и OperatingSystem для респондентов, у которых Rexperience is "Never used" *или* кто смотрел TV 5 или более часов на прошлой неделе. 

```{r}
subset(survey, (survey$Rexperience == "Never used") & (survey$TVhours >= 5), select = c(Program, OperatingSystem))
```


### Задача 5: практика программирования

##### (a) Bar graph

Создайте столбчатую диаграмму ответов респондентов по Rexperience 

```{r, fig.align='center', fig.width=7, fig.height=4}
plot(survey$Rexperience)
```

##### (b) Inline code 

Замените все знаки вопроса в следующем параграфе inline кодом, дополняющим подходящую информацию
Replace all occurrences of ???? in the paragraph below with an inline code chunk supplying the appropriate information.

> Из `r nrow(survey)` респондентов опроса, `r length(which(survey$Program != "MISM"))` НЕ были в программе MISM. Мы обнаружили, что `r round(length(which(survey$OperatingSystem == "Mac OS X"))/nrow(survey)*100,2)`% от числа студентов в классе используют Mac OS X.  `r round(length(which(subset(survey, survey$Program == "MISM")$Rexperience == "Basic competence"))/nrow(subset(survey, survey$Program == "MISM"))*100,2)`% от MISM студентов имеют базовые компетенции в R.

### Задача с пятницы 11.10.2019.

Повернуть матрицу на 90 градусов

```{r}
rotate <- function(m){
  a <- unlist(attributes(m), use.names = F)
  m <- t(m)
  for(i in 0:a[2]){
    m[i,]=rev(m[i,])
  }
  return (m)
}
mx <- matrix(1:6,nrow = 2, ncol = 3)
mx
rotate(mx)

# В R нашелся синтаксический сахар.
rotate <- function(m){
  t(apply(m, 2, rev))
}

mx <- matrix(1:6,nrow = 2, ncol = 3)
mx
rotate(mx)
```

